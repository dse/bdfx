#!/usr/bin/env perl
use warnings;
use strict;

my $bdfx = BDFX->new();
while (<>) {
    $bdfx->parse_line($_);
}

package BDFX {
    sub new {
        my ($class, %args) = @_; my $self = bless(\%args, $class);
        $self->{stage} = 'info';
        $self->{scalar} = {};
        $self->{array} = {};
        $self->{string} = {};
        $self->{multi_string} = { scalar => {},
                                  array => {},
                                  string => {} };
        $self->{prop} = { scalar => {},
                          array => {},
                          string => {},
                          multi_scalar => {},
                          multi_array => {},
                          multi_string => {} };
        $self->{stage} = 'info';
        $self->{other} = [];
        $self->{prop}->{other} = [];
        return $self;
    }
    sub parse_line {
        my ($self, $line) = @_;
        local $_ = $line;
        s{\R\z}{};
        next if !m{\S};         # blank lines
        next if m{^\s*#};       # comment lines not part of the font
        my $word;               # such as COMMENT or STARTPROPERTIES
        if (s{^\s*(\S+)}{}) {
            $word = lc($1);
        }
        my $rest_of_line = $_;  # immediately following the word "COMMENT"
        my @data = split(' ', $rest_of_line); # for $self->{array} and $self->{scalar};

        my $string = $rest_of_line; # trim whole string for $self->{string}
        $string =~ s{^\s+}{};
        $string =~ s{\s+$}{};   #

        if ($self->{stage} eq 'info') { # start of file, or after ENDPROPERTIES
            if ($word eq 'startproperties') {
                $self->{stage} = 'properties'; return;
            }
            if ($word eq 'chars') {
                $self->{stage} = 'chars'; return;
            }
            if ($word eq 'startchar') {
                $self->start_char($data[0]); $self->{stage} = 'char'; return;
            }
            if ($word eq 'endfont') {
                $self->{stage} = 'eof'; return;
            }

            if ($word eq 'comment') {
                push(@{$self->{comments}}, $rest_of_line);
                return;
            }
            $self->{string}->{$word} = $string; # "<width> <height> <x> <y>"
            $self->{array}->{$word} = [@data]; # bbx <width> <height> <x> <y>
            $self->{scalar}->{$word} = $data[0]; # <width>
            push(@{$self->{multi_string}->{$word}}, $string); # "<width> <height> <x> <y>"
            push(@{$self->{multi_array}->{$word}}, [@data]); # bbx <width> <height> <x> <y>
            push(@{$self->{multi_scalar}->{$word}}, $data[0]); # <width>
            return;
        }
        if ($self->{stage} eq 'properties') { # after STARTPROPERTIES
            if ($word eq 'endproperties') {
                $self->{stage} = 'info'; return;
            }
            if ($word eq 'chars') {
                $self->{stage} = 'chars'; return;
            }
            if ($word eq 'startchar') {
                $self->start_char($data[0]); $self->{stage} = 'char'; return;
            }
            if ($word eq 'endfont') {
                $self->{stage} = 'eof'; return;
            }

            my $prop = $self->{prop};
            $prop->{string}->{$word} = $string; # "<width> <height> <x> <y>"
            $prop->{array}->{$word} = [@data]; # bbx <width> <height> <x> <y>
            $prop->{scalar}->{$word} = $data[0]; # <width>
            push(@{$prop->{multi_string}->{$word}}, $string); # "<width> <height> <x> <y>"
            push(@{$prop->{multi_array}->{$word}}, [@data]); # bbx <width> <height> <x> <y>
            push(@{$prop->{multi_scalar}->{$word}}, $data[0]); # <width>
            return;
        }
        if ($self->{stage} == 'chars') { # after CHARS
            if ($word eq 'startchar') {
                my $name = $data[0];
                $self->start_char($name);
                $self->{stage} = 'char'; return;
            }
            if ($word eq 'endfont') {
                $self->{stage} = 'eof'; return;
            }
            die;
        }
        if ($self->{stage} == 'char') { # after STARTCHAR
            my $char = $self->{char};
            die if !defined $char;
            if ($word eq 'bitmap') { $self->{stage} = 'bitmap'; return; }

            $char->{string}->{$word} = $string; # "<width> <height> <x> <y>"
            $char->{array}->{$word} = [@data]; # bbx <width> <height> <x> <y>
            $char->{scalar}->{$word} = $data[0]; # <width>
            push(@{$char->{multi_string}->{$word}}, $string); # "<width> <height> <x> <y>"
            push(@{$char->{multi_array}->{$word}}, [@data]); # bbx <width> <height> <x> <y>
            push(@{$char->{multi_scalar}->{$word}}, $data[0]); # <width>
            return;
        }
        if ($self->{stage} == 'bitmap') { # after BITMAP
            my $char = $self->{char};
            die if !defined $char;
            if ($word =~ m{^[0-9A-fa-f]+$}) { push(@{$char->{bitmap}}, lc($word)); return; }
            if ($word eq 'endchar') { $self->{stage} = 'chars'; return; }
            die;
        }
        if ($self->{stage} == 'eof') {  # after ENDFONT
            # do nothing
        }
    }
    sub start_char {
        my ($self, $name) = @_;
        my $char = $self->{char} = BDFX::Char->new(name => $name, font => $self);
        push(@{$self->{chars}}, $char);
    }
    sub finalize {
        my ($self) = @_;
        my $font_name = $self->{info}->{font}->{scalar};
        if ($font_name =~ m{^(?:-[^-]*){14}$}x) {
            $font_name =~ s{^-}{};
            my @xlfd = split('-', $font_name);
            $self->{xlfd} = [@xlfd];
        }
    }

    sub get_scalar {
        my ($self, $name) = @_;
        my $result = $self->{scalar}->{$name};
        return $result;
    }
    sub get_array {
        my ($self, $name, $idx) = @_;
        return $self->{array}->{$name}->[$idx] if defined $idx;
        my @result = @{$self->{array}->{$name}};
        return wantarray ? @result : [@result];
    }
    sub get_string {
        my ($self, $name) = @_;
        my $result = $self->{string}->{$name};
        return $result;
    }
    sub get_prop_scalar {
        my ($self, $name) = @_;
        my $result = $self->{prop}->{scalar}->{$name};
        return $result;
    }
    sub get_prop_array {
        my ($self, $name, $idx) = @_;
        return $self->{prop}->{array}->{$name}->[$idx] if defined $idx;
        my @result = @{$self->{prop}->{array}->{$name}};
        return wantarray ? @result : [@result];
    }
    sub get_prop_string {
        my ($self, $name) = @_;
        my $result = $self->{prop}->{string}->{$name};
        return $result;
    }

    use POSIX qw(round);

    # global font info
    sub get_startfont {
        my ($self) = @_;
        return $self->get_scalar('startfont');
    }
    sub get_comments {
        my ($self) = @_;
        return @{$self->{comments}};
    }
    sub get_contentversion {
        my ($self) = @_;
        return $self->get_scalar('contentversion');
    }
    sub get_font_name {
        my ($self) = @_;
        return $self->get_scalar('font');
    }
    sub get_font_bounding_box {
        my ($self) = @_;
        return $self->array('fontboundingbox');
    }
    sub get_metrics_set {
        my ($self) = @_;
        return $self->get_scalar('metricsset');
    }
    sub get_swidth {
        my ($self) = @_;
        return $self->get_array('swidth');
    }
    sub get_dwidth {
        my ($self) = @_;
        return $self->get_array('dwidth');
    }
    sub get_swidth1 {
        my ($self) = @_;
        return $self->get_array('swidth1');
    }
    sub get_dwidth1 {
        my ($self) = @_;
        return $self->get_array('dwidth1');
    }
    sub get_vvector {
        my ($self) = @_;
        return $self->get_array('vvector');
    }

    sub get_pixel_size {
        my ($self) = @_;
        my $dppi = 722.7;
        return $self->get_prop_scalar('pixel_size') // $self->get_xlfd_pixel_size() // $self->calc_pixel_size();
    }
    sub get_point_size {
        my ($self) = @_;
        return $self->get_prop_scalar('point_size') // $self->get_xlfd_point_size() // $self->get_array('size', 0) // $self->calc_point_size();
    }
    sub get_resolution_x {
        my ($self) = @_;
        return $self->get_prop_scalar('resolution_x') // $self->get_xlfd_resolution_x() // $self->get_array('size', 1) // $self->calc_resolution_x();
    }
    sub get_resolution_y {
        my ($self) = @_;
        return $self->get_prop_scalar('resolution_y') // $self->get_xlfd_resolution_y() // $self->get_array('size', 2)// $self->calc_resolution_y();
    }

    sub calc_pixel_size {
        my ($self) = @_;
        return round($self->get_resolution_y() * $self->get_point_size() / 722.7);
    }
    # sub calc_point_size {
    #     my ($self) = @_;
    #     # Design POINT_SIZE cannot be calculated or approximated.
    # }
    # sub calc_resolution_x {
    #     my ($self) = @_;
    #     # RESOLUTION_X cannot be calculated or approximated.
    # }
    # sub calc_resolution_y {
    #     my ($self) = @_;
    #     # RESOLUTION_Y cannot be calculated or approximated.
    # }

    sub get_foundry               { my ($self) = @_; return $self->get_prop_scalar('foundry')          // $self->get_xlfd_foundry(); }
    sub get_family_name           { my ($self) = @_; return $self->get_prop_scalar('family_name')      // $self->get_xlfd_family_name(); }
    sub get_weight_name           { my ($self) = @_; return $self->get_prop_scalar('weight_name')      // $self->get_xlfd_weight_name() // 'Medium'; }
    sub get_slant                 { my ($self) = @_; return $self->get_prop_scalar('slant')            // $self->get_xlfd_slant() // 'R'; }
    sub get_setwidth_name         { my ($self) = @_; return $self->get_prop_scalar('setwidth_name')    // $self->get_xlfd_setwidth_name() // 'Normal'; }
    sub get_add_style_name        { my ($self) = @_; return $self->get_prop_scalar('add_style_name')   // $self->get_xlfd_add_style_name(); }
    sub get_spacing               { my ($self) = @_; return $self->get_prop_scalar('spacing')          // $self->get_xlfd_spacing(); }
    sub get_average_width         { my ($self) = @_; return $self->get_prop_scalar('average_width')    // $self->get_xlfd_average_width(); }
    sub get_charset_registry      { my ($self) = @_; return $self->get_prop_scalar('charset_registry') // $self->get_xlfd_charset_registry(); }
    sub get_charset_encoding      { my ($self) = @_; return $self->get_prop_scalar('charset_encoding') // $self->get_xlfd_charset_encoding(); }

    # xlfd properties
    sub get_xlfd_foundry          { my ($self) = @_; return $self->get_xlfd('foundry', 0); }
    sub get_xlfd_family_name      { my ($self) = @_; return $self->get_xlfd('family_name', 1); }
    sub get_xlfd_weight_name      { my ($self) = @_; return $self->get_xlfd('weight_name', 2); }
    sub get_xlfd_slant            { my ($self) = @_; return $self->get_xlfd('slant', 3); }
    sub get_xlfd_setwidth_name    { my ($self) = @_; return $self->get_xlfd('setwidth_name', 4); }
    sub get_xlfd_add_style_name   { my ($self) = @_; return $self->get_xlfd('add_style_name', 5); }
    sub get_xlfd_pixel_size       { my ($self) = @_; return $self->get_xlfd('pixel_size', 6); }
    sub get_xlfd_point_size       { my ($self) = @_; return $self->get_xlfd('point_size', 7); }
    sub get_xlfd_resolution_x     { my ($self) = @_; return $self->get_xlfd('resolution_x', 8); }
    sub get_xlfd_resolution_y     { my ($self) = @_; return $self->get_xlfd('resolution_y', 9); }
    sub get_xlfd_spacing          { my ($self) = @_; return $self->get_xlfd('spacing', 10); }
    sub get_xlfd_average_width    { my ($self) = @_; return $self->get_xlfd('average_width', 11); }
    sub get_xlfd_charset_registry { my ($self) = @_; return $self->get_xlfd('charset_registry', 12); }
    sub get_xlfd_charset_encoding { my ($self) = @_; return $self->get_xlfd('charset_encoding', 13); }
    sub get_xlfd {
        my ($self, $prop_name, $prop_number) = @_;
        return $self->{prop}->{$prop_name} // $self->{xlfd}->[$prop_number];
    }

    # other font properties
    sub get_min_space { }
    sub get_norm_space { }
    sub get_max_space { }
    sub get_end_space { }
    sub get_avg_capital_width { }
    sub get_avg_lowercase_width { }
    sub get_quad_width { }
    sub get_figure_width { }
    sub get_superscript_x { }
    sub get_superscript_y { }
    sub get_subscript_x { }
    sub get_subscript_y { }
    sub get_superscript_size { }
    sub get_subscript_size { }
    sub get_small_cap_size { }
    sub get_underline_position { }
    sub get_underline_thickness { }
    sub get_strikeout_ascent { }
    sub get_strikeout_descent { }
    sub get_italic_angle { }
    sub get_cap_height { }
    sub get_x_height { }
    sub get_relative_setwidth { }
    sub get_relative_weight { }
    sub get_weight { }
    sub get_resolution { }
    sub get_font { }
    sub get_face_name { }
    sub get_full_name { }
    sub get_copyright { }
    sub get_notice { }
    sub get_destination { }
    sub get_font_type { }
    sub get_font_version { }
    sub get_rasterizer_name { }
    sub get_rasterizer_version { }
    sub get_raw_ascent { }
    sub get_raw_descent { }
    sub get_raw__all { }
    sub get_axis_names { }
    sub get_axis_limits { }
    sub get_axis_types { }

    # other font properties
    # sub calc_min_space { }
    # sub calc_norm_space { }
    # sub calc_max_space { }
    # sub calc_end_space { }
    # sub calc_avg_capital_width { }
    # sub calc_avg_lowercase_width { }
    # sub calc_quad_width { }
    # sub calc_figure_width { }
    # sub calc_superscript_x { }
    # sub calc_superscript_y { }
    # sub calc_subscript_x { }
    # sub calc_subscript_y { }
    # sub calc_superscript_size { }
    # sub calc_subscript_size { }
    # sub calc_small_cap_size { }
    # sub calc_underline_position { }
    # sub calc_underline_thickness { }
    # sub calc_strikeout_ascent { }
    # sub calc_strikeout_descent { }
    # sub calc_italic_angle { }
    # sub calc_cap_height { }
    # sub calc_x_height { }
    # sub calc_relative_setwidth { }
    # sub calc_relative_weight { }
    # sub calc_weight { }
    # sub calc_resolution { }
    # sub calc_font { }
    # sub calc_face_name { }
    # sub calc_full_name { }
    # sub calc_copyright { }
    # sub calc_notice { }
    # sub calc_destination { }
    # sub calc_font_type { }
    # sub calc_font_version { }
    # sub calc_rasterizer_name { }
    # sub calc_rasterizer_version { }
    # sub calc_raw_ascent { }
    # sub calc_raw_descent { }
    # sub calc_raw__all { }
    # sub calc_axis_names { }
    # sub calc_axis_limits { }
    # sub calc_axis_types { }
};

package BDFX::Char {
    sub new {
        my ($class, %args) = @_;
        my $self = bless(\%args, $class);
        return $self;
    }
    sub encoding {
        my ($self) = @_;
    }
    sub nonstandard_encoding {
        my ($self) = @_;
    }
    sub swidth {
        my ($self) = @_;
    }
    sub dwidth {
        my ($self) = @_;
    }
    sub swidth1 {
        my ($self) = @_;
    }
    sub dwidth1 {
        my ($self) = @_;
    }
    sub vvector {
        my ($self) = @_;
    }
    sub bounding_box {
        my ($self) = @_;
    }
    sub bitmap_data {
        my ($self) = @_;
    }
};
